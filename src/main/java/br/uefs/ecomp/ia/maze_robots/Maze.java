package br.uefs.ecomp.ia.maze_robots;

public class Maze {

	public static final char EMPTY = ' ';
	public static final char WALL = '#';
	public static final char START = 'I';
	public static final char END = 'F';

	public static Maze[] mazes = new Maze[] {

			new Maze(new char[][] {
					/*
					###########
					#I       F#
					###########
					*/
					{ '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#' },
					{ '#', 'I', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'F', '#' },
					{ '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#' }
			}),
			new Maze(new char[][] {
					/*
					###########
					#I        #
					#         #
					#        F#
					###########
					*/
					{ '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#' },
					{ '#', 'I', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#' },
					{ '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#' },
					{ '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'F', '#' },
					{ '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#' }
			}),
			new Maze(new char[][] {
					/*
					###########
					#I        #
					#######   #
					  #   #
					  #   #
					  ##F##
					  #####
					*/
					{ '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#' },
					{ '#', 'I', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#' },
					{ '#', '#', '#', '#', '#', '#', '#', ' ', ' ', ' ', '#' },
					{ ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#' },
					{ ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#' },
					{ ' ', ' ', ' ', ' ', ' ', ' ', '#', '#', 'F', '#', '#' },
					{ ' ', ' ', ' ', ' ', ' ', ' ', '#', '#', '#', '#', '#' }
			}),
			new Maze(new char[][] {
					/*
					###########
					#F        #
					####   ####
					   #   #
					   #   #
					   ##I##
					   #####
					*/
					{ '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#' },
					{ '#', 'F', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#' },
					{ '#', '#', '#', '#', ' ', ' ', ' ', '#', '#', '#', '#' },
					{ ' ', ' ', ' ', '#', ' ', ' ', ' ', '#' },
					{ ' ', ' ', ' ', '#', ' ', ' ', ' ', '#' },
					{ ' ', ' ', ' ', '#', '#', 'I', '#', '#' },
					{ ' ', ' ', ' ', '#', '#', '#', '#', '#' }
			}),
			new Maze(new char[][] {
					/*
					###########
					#I        #
					####   ####
					#        F#
					###########
					*/
					{ '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#' },
					{ '#', 'I', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#' },
					{ '#', '#', '#', '#', ' ', ' ', ' ', '#', '#', '#', '#' },
					{ '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'F', '#' },
					{ '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#' }
			}),
			new Maze(new char[][] {
					/*
					##############
					#I           #
					# ####  #### #
					#            #
					# ## #### ## #
					# ##      ## #
					# ## #### ## #
					#            #
					# ####  #### #
					#           F#
					##############
					*/
					{ '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#' },
					{ '#', 'I', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#' },
					{ '#', ' ', '#', '#', '#', '#', ' ', ' ', '#', '#', '#', '#', ' ', '#' },
					{ '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#' },
					{ '#', ' ', '#', '#', ' ', '#', '#', '#', '#', ' ', '#', '#', ' ', '#' },
					{ '#', ' ', '#', '#', ' ', ' ', ' ', ' ', ' ', ' ', '#', '#', ' ', '#' },
					{ '#', ' ', '#', '#', ' ', '#', '#', '#', '#', ' ', '#', '#', ' ', '#' },
					{ '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#' },
					{ '#', ' ', '#', '#', '#', '#', ' ', ' ', '#', '#', '#', '#', ' ', '#' },
					{ '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'F', '#' },
					{ '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#' }
			})
	};

	public static Maze get(int index) {
		return mazes[index];
	}

	private final char maze[][];
	private int sX;
	private int sY;
	private int eX;
	private int eY;

	private Maze(char[][] maze) {
		this.maze = maze;
		sX = -1;
		sY = -1;
		eX = -1;
		eY = -1;

		for (int x = 0; x < maze.length; x++) {
			for (int y = 0; y < maze[x].length; y++) {
				if (maze[x][y] != EMPTY && maze[x][y] != WALL && maze[x][y] != START && maze[x][y] != END)
					throw new RuntimeException("Labirinto com posicao invÃ¡lida: " + maze[x][y]);

				if (maze[x][y] == START) {
					sX = x;
					sY = y;
				}

				if (maze[x][y] == END) {
					eX = x;
					eY = y;
				}
			}
		}

		if (sX == -1)
			throw new RuntimeException("Labirinto sem inicio");
		if (eX == -1)
			throw new RuntimeException("Labirinto sem fim");
	}

	public char[][] getMaze() {
		return maze;
	}

	public int getSX() {
		return sX;
	}

	public int getSY() {
		return sY;
	}

	public int getEX() {
		return eX;
	}

	public int getEY() {
		return eY;
	}

	public boolean isEmpty(int x, int y) {
		return maze[x][y] == 'I' || maze[x][y] == ' ';
	}

	public boolean isWall(int x, int y) {
		return maze[x][y] == '#';
	}

	public boolean isEnd(int x, int y) {
		return maze[x][y] == 'F';
	}
}
